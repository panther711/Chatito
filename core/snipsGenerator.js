const utils = require("./utils");

/**
 * Transforms the chatito dataset from the intermediate representation to a snips dataset. This are the arguments:
 * 
 * @param {Object[]} items - array of chatito intermediate representation examples. e.g.: [{ text: "lights on", intent: "lightChange", entities: [{"start": 7, "end": 9, "value": "on", "entity": "switch"}] }]
 * @param {Object} definitions - the entity definitions with their intermediate representation abstract syntax three
 * @param {Object} options - custom options for the snips nlu dataset settings. e.g.: { language: "es", entities: { artist: { automatically_extensible: true} } };
 * @returns {Object}
 */
function snipsDatasetAdapter(items, definitions, options) {
    const dataset = { language: "en", entities: {}, intents: {} };
    if (options) { utils.mergeDeep(dataset, options); }
    items.forEach(item => {
        if (!dataset.intents[item.action]) { dataset.intents[item.action] = { utterances: [] }; }
        const utterances = dataset.intents[item.action].utterances;
        const compareFunction = (a, b) => {
            if (a.item.start === b.item.start) { return 0; }
            return (a.item.start < b.item.start) ? -1 : 1;
        };
        const example = { data: [] };
        let stringIndex = 0;
        Object.keys(item.arg).map(k => ({ item: item.arg[k], key: k })).sort(compareFunction).forEach((e) => {
            if (e.item.start !== stringIndex) { example.data.push({ text: item.id.slice(stringIndex, e.item.start) }); }
            const entity = definitions.args[e.key].entity || e.key;
            const textValue = item.id.slice(e.item.start, e.item.end);
            example.data.push({
                text: textValue,
                slot_name: e.key,
                entity,
            });
            stringIndex = e.item.end;
            if (!dataset.entities[entity]) { dataset.entities[entity] = {}; }
            const snipsEntityDef = dataset.entities[entity];
            if (e.item.value) { // if entity has value property, means it has aliases
                snipsEntityDef.use_synonyms = true;
                if (snipsEntityDef.automatically_extensible === undefined) {
                    snipsEntityDef.automatically_extensible = false;
                }
                if (!snipsEntityDef.data) { snipsEntityDef.data = []; }
                let entityFound = snipsEntityDef.data.find(d => d.value === e.item.value);
                if (!entityFound) {
                    entityFound = { value: e.item.value, synonyms: [] };
                    snipsEntityDef.data.push(entityFound);
                }
                let synonymFound = entityFound.synonyms.find(s => s === textValue);
                if (e.item.value !== textValue && !synonymFound) { entityFound.synonyms.push(textValue); }
            }
        });
        if (stringIndex !== item.id.length) { example.data.push({ text: item.id.slice(stringIndex, item.id.length) }); }
        utterances.push(example);
    });
    return dataset;
}

/**
 * Transforms the chatito dataset from the intermediate representation to a snips nlu dataset. This are the arguments:
 * 
 * @param {Object} dataset - The snips format dataset generated by snipsDatasetAdapter
 * @param {Object} max - If there are less examples than this number, there wont testing examples
 * @param {Object} min - If there are less examples than this number, duplicates the data and no testing examples.
 * @returns {Object} - Returns an object with two properties (the two datasets): e.g.: { dataset: {} , testingExamples: [] }
 */
function snipsDatasetPostProcessor(dataset, max, min) {
    if (!dataset || !dataset.intents || !Object.keys(dataset.intents).length) { throw new Error("Snips post processor error: invalid dataset format"); }
    if (max && min && min > max) {
        throw new Error("Min number of training examples can't be higher than max.");
    }
    const stats = { total: 0, training: 0, testing: 0 };
    Object.keys(dataset.intents).map(i => {
        utils.shuffle(dataset.intents[i].utterances);
        stats.total += dataset.intents[i].utterances.length;
    });
    let testingExamples = [];
    stats.training = stats.total;
    if (stats.total > max) {
        stats.training = 0;
        const proportion = max / stats.total;
        Object.keys(dataset.intents).forEach(i => {
            const currentIntentExamples = dataset.intents[i].utterances;
            const trainingExamplesNum = Math.round(currentIntentExamples.length * proportion);
            dataset.intents[i].utterances = currentIntentExamples.slice(0, trainingExamplesNum);
            const testing = currentIntentExamples.slice(trainingExamplesNum);
            testingExamples.push({
                intent: i,
                examples: testing
            });
            stats.training += dataset.intents[i].utterances.length;
            stats.testing += testing.length;
        });
    } else if (stats.total < min) {
        const proportion = min / stats.total;
        stats.training = 0;
        Object.keys(dataset.intents).forEach(i => {
            const currentIntentExamples = dataset.intents[i].utterances;
            const trainingExamplesNum = Math.round(currentIntentExamples.length * proportion);
            while (dataset.intents[i].utterances.length < trainingExamplesNum) {
                dataset.intents[i].utterances = dataset.intents[i].utterances.concat(
                    currentIntentExamples.slice(0, min - dataset.intents[i].utterances.length)
                );
            }
            stats.training += dataset.intents[i].utterances.length;
        });
    }
    return { dataset, testingExamples, stats };
}

module.exports = {
    adapter: snipsDatasetAdapter,
    postProcessor: snipsDatasetPostProcessor,
};
